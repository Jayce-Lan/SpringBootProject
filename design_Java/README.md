# 设计模式

## 23种设计模式

### 创建型模式（Creational Patterns）

1. **单例模式（Singleton）** - 确保一个类只有一个实例，并提供一个全局访问点。
2. **工厂方法模式（Factory Method）** - 定义一个用于创建对象的接口，让子类决定实例化哪一个类。
3. **抽象工厂模式（Abstract Factory）** - 创建相关或依赖对象的家族，而不需明确指定具体类。
4. **建造者模式（Builder）** - 构建一个复杂的对象，并允许按步骤构造。
5. **原型模式（Prototype）** - 通过拷贝现有的实例创建新的实例，而不是通过新建。

### 结构型模式（Structural Patterns）

6. **适配器模式（Adapter）** - 允许对象间的接口不兼容问题。
7. **装饰器模式（Decorator）** - 动态地给一个对象添加额外的职责。
8. **代理模式（Proxy）** - 为其他对象提供一个代替或占位符以控制对它的访问。
9. **外观模式（Facade）** - 提供一个统一的高层接口，用于访问子系统中的一群接口。
10. **桥接模式（Bridge）** - 将抽象部分与其实现部分分离，使它们可以独立地变化。
11. **组合模式（Composite）** - 将对象组合成树形结构以表示“部分-整体”的层次结构。
12. **享元模式（Flyweight）** - 通过共享来高效地支持大量细粒度的对象。

### 行为型模式（Behavioral Patterns）

13. **策略模式（Strategy）** - 定义一系列算法，把它们一个个封装起来，并使它们可互换。
14. **模板方法模式（Template Method）** - 在方法中定义算法的框架，延迟到子类中实现。
15. **观察者模式（Observer）** - 对象间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。
16. **迭代器模式（Iterator）** - 顺序访问一个聚合对象中的各个元素，不暴露其内部的表示。
17. **责任链模式（Chain of Responsibility）** - 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
18. **命令模式（Command）** - 将请求封装为一个对象，从而使用户可用不同的请求对客户进行参数化。
19. **备忘录模式（Memento）** - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
20. **状态模式（State）** - 允许一个对象在其内部状态发生改变时改变其行为。
21. **访问者模式（Visitor）** - 对象结构中的元素对象分别作用于一个访问者对象，让这个访问者对象决定如何处理每一个元素。
22. **中介者模式（Mediator）** - 定义一个中介对象来简化原有对象的交互。
23. **解释器模式（Interpreter）** - 定义一个语言的文法，并构建一个解释器，这个解释器可以解释和执行语言中的句子。